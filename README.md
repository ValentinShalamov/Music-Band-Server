
# Music Band Server

## Введение

**Music Band Server** - сервер многопоточного клиент-серверного приложения, предназначенного для управления коллекцией объектов `MusicBands` в интерактивном режиме. 

В данном **readme** описывается только `серверная` часть приложения. С `клиентской` частью (в т.ч. с инструкцией по работе с клиентом) вы можете ознакомиться, перейдя по ссылке [Client](https://github.com/ValentinShalamov/Music-Band-Client)

## Особенности реализации
- Сетевое взаимодействие реализовано с помощью возможностей пакета `java.nio` в неблокирующем асинхронном режиме
- Обмен данными с клиентом осуществляется по протоколу `TCP`
- Чтение запросов выполняется в `неблокирующем` режиме
- Обработка считанных запросов осуществляется в многопоточном режиме с помощью `Thread pool`
- Хранение созданных `MusicBands` и зарегистрированных пользователей происходит в базе данных `PostgreSQL`
- Передача запросов в базу данных осуществляется многопоточном режиме c помощью `Connection pool` 
- Передача ответов клиенту происходит с помощью `блокирующей очереди` с использованием `producer consumer pattern`
- Для реализация внутреннего кэширования используется `ConcurrentHashMap`
- Работа с кэшем осуществляется с помощью `StreamAPI`
- Логирование различных этапов работы сервера

## Диаграмма компонентов сервера
![App Screenshot](https://github.com/ValentinShalamov/Music-Band-Server/blob/master/Components.png)
## Используемый стек

- Apache Commons DBCP (для реализации пула соединений к базе данных)
- Apache Commons Codec (для хэширование паролей пользователей)
- Gson (для диссериализации запросов от клиента)
- JUnit 5
- Mockito
- PostgreSQL

## Принцип работы

Принцип работы сервера разделяется на несколько этапов:

### 1. Ожидание клиентских подключений и регистрация каналов на селекторе

Сервер ожидает в блокирующем режиме подключений со стороны клиента, как только случается подключение, сервер регистрирует клиенский сокет `SocketChannel` на селекторе и для сервера устанавливается ключ на чтение из канала. 

### 2. Получение запроса от клиента

#### Конвенция по обмену сообщениями между клиентом и сервером


Между сервером и клиентом существует конвенция по обмену сообщениями. Клиент или сервер, перед отправкой сообщения, добавляет в начало запроса длину сообщения, переведенную в массив из 4 байт. 

При получении такого сообщения, клиент/сервер считывает первые 4 байта, интерпретирует их в длину сообщения, которое необходимо считать, создает буфер такой длины и ожидает пока буфер заполнится, после этого происходит дальнейшная работа с сообщением.

Это создано для того, чтобы клиент/сервер обрабатывал только полностью считанные сообщения, не реагируя на частичные.

#### Чтение запроса
Клиент записывает запрос в `SocketChannel` в виде `json` строки, разбитой на байты. Сервер реагирует на запрос и в неблокирующем режиме считывает байты из канала в соответствующий для каждого подключенного клиента буфер. Далее управление передается пулу потоков, а `main thread` возвращается на ожидание новых запросов.


### 3. Обработка запроса
После того, как собирается полное сообщение, обработка запроса передается в специальный класс `MultithreadedRequestHandler`. Данный класс хранит в себе `ExecutorService` и `BlockingQueue`.

Данный класс передает обработку запроса пулу потоков. При обращении к базе данных потоки получают соединение у пула соединений.

### 4. Отправка результатов
После обработки запроса от клиента, результат помещается в блокирующую очередь в классе `MultithreadedRequestHandler`.

Результаты обработки запросов из блокирующей очереди отправляются клиенту отдельным потоком, инициализированным в классе `Server`.

## Данные для связи
Email для связи: valentin98shalamov@gmail.com
