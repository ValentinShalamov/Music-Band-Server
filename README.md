
# Music Band Server

## Введение

**Music Band Server** - многопоточный сервер для интерактивного управления коллекцией музыкальных групп `MusicBands`. Обрабатывает и выполняет команды, полученные от клиента через протокол `TCP`.

В данном **readme** описывается только `серверная` часть приложения. С `клиентской` частью (в т.ч. с инструкцией по работе с клиентом) вы можете ознакомиться, перейдя по ссылке [Client](https://github.com/ValentinShalamov/Music-Band-Client)

## Особенности реализации
- Сетевое взаимодействие реализовано с использованием возможностей пакета `java.nio` в неблокирующем асинхронном режиме
- Обмен данными с клиентом осуществляется по протоколу `TCP` в формате `json`
- Обработка считанных запросов осуществляется в многопоточном режиме с использованием пула потоков `Thread Pool`
- Данные пользователей и их музыкальных банд хранятся в базе данных `PostgreSQL`
- Выполнение запросов к базе данных организовано с использованием пула соединений `Connection Pool`, для корректной работы в многопоточном режиме
- Передача ответов клиенту осуществляется через блокирующую очередь `BlockingQueue` с применением паттерна `Producer-Consumer`
- Для повышения скорости выполнения запросов на чтение, используется `кэширование данных`, организованное с помощью `ConcurrentHashMap`
- Реализовано логирование различных этапов работы сервера с использованием пакета `java.util.logging`

## Диаграмма компонентов сервера
![App Screenshot](https://github.com/ValentinShalamov/Music-Band-Server/blob/master/Components.png)
## Используемый стек

- Apache Commons DBCP (для реализации пула соединений к базе данных)
- Apache Commons Codec (для хэширования паролей пользователей)
- Gson (для десериализации запросов от клиента)
- JUnit 5
- Mockito
- PostgreSQL

## Принцип работы

Принцип работы сервера разделяется на несколько этапов:

### 1. Ожидание клиентских подключений и регистрация каналов на селекторе

Сервер ожидает в блокирующем режиме подключений со стороны клиента, как только случается подключение, сервер регистрирует клиенский сокет `SocketChannel` на селекторе и для сервера устанавливается ключ на чтение из канала. 

### 2. Получение запроса от клиента

#### Конвенция по обмену сообщениями между клиентом и сервером


Между сервером и клиентом существует конвенция по обмену сообщениями. Клиент или сервер, перед отправкой сообщения, добавляет в начало запроса длину сообщения, переведенную в массив из 4 байт. 

При получении такого сообщения, клиент/сервер считывает первые 4 байта, интерпретирует их в длину сообщения, которое необходимо считать, создает буфер такой длины и ожидает пока буфер заполнится, после этого происходит дальнейшная работа с сообщением.

Это создано для того, чтобы клиент/сервер обрабатывал только полностью считанные сообщения, не реагируя на частичные.

#### Чтение запроса
Клиент записывает запрос в `SocketChannel` в виде `json` строки, разбитой на байты. Сервер реагирует на запрос и в неблокирующем режиме считывает байты из канала в соответствующий для каждого подключенного клиента буфер. Далее управление передается пулу потоков, а `main thread` возвращается на ожидание новых запросов.


### 3. Обработка запроса
После того, как собирается полное сообщение, обработка запроса передается в специальный класс `MultithreadedRequestHandler`. Данный класс хранит в себе `ExecutorService` и `BlockingQueue`.

Данный класс передает обработку запроса пулу потоков. При обращении к базе данных потоки получают соединение у пула соединений.

### 4. Отправка результатов
После обработки запроса от клиента, результат помещается в блокирующую очередь в классе `MultithreadedRequestHandler`.

Результаты обработки запросов из блокирующей очереди отправляются клиенту отдельным потоком, инициализированном в классе `Server`.

## Данные для связи
Email для связи: valentin98shalamov@gmail.com
